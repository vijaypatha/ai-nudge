# backend/agent_core/tools/communication.py

from typing import List, Optional # For type hinting lists and optional values
from data.models.message import ScheduledMessage, ScheduledMessageCreate, MessageStatus # Import message models
from datetime import datetime, timezone # For accurate date/time handling (especially UTC)
import uuid # For generating unique IDs

# In-memory store for scheduled messages (for demonstration purposes only).
# In a real application, these messages would be stored persistently in a database,
# managed by the data_platform/crm.py service.
mock_scheduled_messages_db: List[ScheduledMessage] = []

# Mock function for sending a message immediately.
# This function would be used by AI agents or direct commands when a message
# doesn't need to be scheduled for the future.
def send_message_now(client_id: uuid.UUID, content: str) -> bool:
    """
    Simulates sending a message to a client immediately.
    How it works for the robot: This is like the robot speaking a message
    out loud or sending a text right away.
    Returns True if the sending is "successful" (in this mock, always True), False otherwise.
    """
    print(f"COMM TOOL: Immediately sending message to client {client_id}: '{content[:50]}...' at {datetime.now(timezone.utc).isoformat()}")
    # In a real scenario, this would interact with an external API like Twilio.
    return True

def schedule_message(message_data: ScheduledMessageCreate) -> ScheduledMessage:
    """
    Schedules a message to be sent at a future time.
    This function creates a record for the scheduled message in the system.
    How it works for the robot: This is like the robot carefully writing down
    a message on its "Sticky Note Pad" with the exact time it needs to be sent,
    and then placing it in a "To Be Sent" pile.
    
    - message_data: An object containing the client ID, content, and scheduled_at timestamp.
    Returns the newly created ScheduledMessage object with its unique ID and pending status.
    """
    # Create a new ScheduledMessage object.
    # The 'id' and 'created_at' fields are automatically generated by the model's defaults.
    new_scheduled_msg = ScheduledMessage(
        client_id=message_data.client_id,
        content=message_data.content,
        scheduled_at=message_data.scheduled_at,
        status="pending" # All newly scheduled messages start as 'pending'
    )
    # Add the newly created scheduled message to our in-memory database.
    mock_scheduled_messages_db.append(new_scheduled_msg)
    
    # Print a confirmation message to the console for debugging/observability.
    print(f"COMM TOOL: Scheduled message '{new_scheduled_msg.content[:30]}...' for client {new_scheduled_msg.client_id} at {new_scheduled_msg.scheduled_at.isoformat()}")
    
    # Return the created scheduled message object.
    return new_scheduled_msg

def get_scheduled_messages(status_filter: Optional[MessageStatus] = None) -> List[ScheduledMessage]:
    """
    Retrieves scheduled messages from the system.
    Can optionally filter messages by their status (e.g., "pending", "sent").
    How it works for the robot: This is like the robot looking through its
    "Sticky Note Pad" for all the messages it needs to send, or just the ones
    it has already sent, or any that had problems.
    
    - status_filter: An optional MessageStatus to filter the messages by.
    Returns a list of ScheduledMessage objects.
    """
    if status_filter:
        # If a status filter is provided, return only messages matching that status.
        return [msg for msg in mock_scheduled_messages_db if msg.status == status_filter]
    # If no filter is provided, return all scheduled messages.
    return mock_scheduled_messages_db

def mark_message_as_sent(message_id: uuid.UUID) -> Optional[ScheduledMessage]:
    """
    Marks a specific scheduled message as 'sent'.
    This function would typically be called by a background task after the message
    has actually been delivered.
    How it works for the robot: This is like the robot finding a scheduled message
    on its "Sticky Note Pad" and putting a big checkmark next to it, saying "DONE!"
    
    - message_id: The unique ID of the message to mark as sent.
    Returns the updated ScheduledMessage object, or None if the message was not found.
    """
    for msg in mock_scheduled_messages_db:
        if msg.id == message_id:
            msg.status = "sent" # Update the status to 'sent'
            msg.sent_at = datetime.now(timezone.utc) # Record the time it was sent
            print(f"COMM TOOL: Marked message {message_id} as SENT at {msg.sent_at.isoformat()}")
            return msg
    return None # Return None if the message ID was not found

def mark_message_as_failed(message_id: uuid.UUID, error: str) -> Optional[ScheduledMessage]:
    """
    Marks a specific scheduled message as 'failed'.
    This function would be called if there was an error during delivery.
    How it works for the robot: This is like the robot finding a scheduled message
    and writing a big "Oops!" next to it, along with what went wrong.
    
    - message_id: The unique ID of the message to mark as failed.
    - error: A string describing the reason for failure.
    Returns the updated ScheduledMessage object, or None if the message was not found.
    """
    for msg in mock_scheduled_messages_db:
        if msg.id == message_id:
            msg.status = "failed" # Update the status to 'failed'
            msg.error_message = error # Store the error message
            msg.sent_at = datetime.now(timezone.utc) # Record the time of attempt
            print(f"COMM TOOL: Marked message {message_id} as FAILED: {error}")
            return msg
    return None # Return None if the message ID was not found